S <- c("logical", "integer", "double", "complex", "character", "raw")
V <- c("logical[]", "integer[]", "double[]", "complex[]", "character[]", "raw[]")
T <- c("list<any>", "class<matrix>")
## "list<logical[]>", "list<integer[]>", "list<double[]>", "list<complex[]>", "list<character[]>", "list<raw[]"

## TYPES: using types that contractr uses (extendable)
TYPES <- c(S, V, T)


#' Performs experiments with library functions or user defined functions and records the result in a dataframe
#'
#' @param  package         package name
#' @param  fun_name        function name
#' @param  fun             function to infer type signature
#' @param  TYPES           a list of predefined types
#' @param  value_generator a function that provides arguments
#' @param  strategy        how to pick the types for each argument in the next run
#' @param  budget          number of calls to fun
## @param  tolerance       number of calls that applies values of the same type permutation
#' @return
#' @importfrom purrr map_dfr
#' @export
#' @examples
#' feedback_loop(fun_name = "add_1", fun = function(x) {x+1}, strategy = "random-feedback", budget = 7)
#' feedback_loop(package = "stringr", fun_name = "str_detect", strategy = "random-db", budget = 343, db_path = "../tests/testthat/db/test_db")
feedback_loop <- function (package = NA,
                           fun_name,
                           fun,
                           types = TYPES,
                           value_generator = generate_val,
                           ## strategy = c("precompute", "precompute-random", "random", "random-feedback", "random-db"),
                           budget,
                           ## tolerance,
                           db_path = NULL) {
  print(fun_name) #for debugging

  states <- list()

  if (!is.na(package)) {
    fun <- get(fun_name, envir=getNamespace(package), mode="function")
  }

  params <- formals(fun)               ## todo: we can inspect default arg here
  num_params <- length(params)
  print(num_params)

  if (num_params == 0) {
    new_states <- lapply(seq(budget), function(x) run_fun(package, fun_name, fun, list()))
    states <- do.call(rbind, new_states)

  } else {
    param_names <- names(params)

    types_to_try <- list()

    while(budget > 0) {
      if (length(states) == 0) {
        generate_types <- generate_types_randomly
      } else {
        last_state <- states[nrow(states), ]
        generate_types <- feedback(last_state)
      }

      types_to_try <- generate_types(types, param_names, last_state)

      mapply(function(name, type){
        params[[name]] <<- value_generator(type, db = !is.null(db_path))
      }, param_names, types_to_try)

      states <- update_states(states, package, fun_name, fun, params)
      budget <- budget - 1
    }
  }

  rownames(states) <- NULL
  states
}


#' Runs function with params and updates states with the result
#'
#' @param states    dataframe containing result of running functions
#' @param package   pacakge name if the function is a library function
#' @param fun_names name of the function
#' @param fun       function
#' @param params    values generated by value generator to plug into the function
update_states <- function(states, package, fun_name, fun, params) {
  args <- params
  new_state <- run_fun(package, fun_name, fun, args)
  purrr::map_dfr(list(states, new_state), function(x) x)
}


#' Decides which strategy to use for picking types in the next round of experiment
#' based on the result of previous run
#'
#' Strategy 1. generate_types_randomly
#' Strategy 2. generate_types_semi_randomly
#' Strategy 3. generate_perms_fixed
#'
#' @param state      result of the last run
#' @return           type picking strategy
feedback <- function(state) {
  if(state$exitval == 0L || state$exitval == 1L) {
    if(state$num_param == 1)
      return(generate_types_randomly)
    else
      return(generate_perms_fixed)
  } else {
    return(generate_types_semi_randomly)
  }
}


#' Pick types randomly
#' Used when feedback is not available (first run) or not useful (function takes one argument)
generate_types_randomly <- function(types, param_names, state=NULL) {
  sample(types, length(param_names), replace = TRUE)
}


#' Pick a type different from previous run in each position of the parameters
#' Used when previous run failed (errored out)
generate_types_semi_randomly <- function(types, param_names, state=NULL) {
  input_type <- state$input_type
  input_types <- stringr::str_split(input_type, " x ")[[1]]

  lapply(input_types, function(type) sample(setdiff(types, type), 1))
}


#' Fix the type of the first parameter, but pick a different type for the rest of the parameters
#' Used when previous run was successful
generate_perms_fixed <- function(types, param_names, state=NULL) {
  input_type <- state$input_type
  input_types <- stringr::str_split(input_type, " x ")[[1]]

  the_rest <- lapply(input_types[-1], function(t) sample(setdiff(types, t), 1))

  c(input_types[[1]], the_rest)
}


#' Runs the function with args and stores the result in a list
#' @param package    package name if the function is a library function
#' @param fun_name   function name
#' @param fun        function
#' @param args       arguments
#' @return           list of the running result and metadata
#' @importfrom tibble  tibble
#' @importfrom contractr  infer_type
#' @export
run_fun <- function(package = NULL, fun_name, fun, args) {
  input_type <- lapply(args, contractr::infer_type)
  combined <- paste0(input_type, collapse=" x ")

  res <- tibble::tibble(package=package,
                        fun_name=fun_name,
                        num_param=length(args),
                        input_type=combined,
                        output_type=NA,
                        exitval=NA,
                        warnmsg=NA,
                        errmsg=NA,
                        sig=NA)

  tryCatch (withCallingHandlers({
    output <- do.call(fun, as.list(args))
    output_type <- contractr::infer_type(output)

    res$output_type <- output_type
    if (is.na(res$exitval)) res$exitval <- 0L
    res$sig <- paste(combined, output_type, sep=" -> ")
  },
  warning = function(w) {
    res$exitval <<- 1L
    res$warnmsg <<- as.character(w)
    invokeRestart("muffleWarning")
  }),
  error = function(e) {
    res$exitval <<- 2L
    res$errmsg <<- as.character(e)
  })

  res
}


#' Generates values based on the type
#' @param type type of value to generate
#' @param db   TRUE if we want values from database
#' @return
#' @export
generate_val <- function(type=NULL, db = FALSE) {
  if (db) {
    if(is.null(type)) {
      return(record::sample_val())
    } else {
      return(record::sample_val(type=type))
    }
  } else {

    outer_type <- gsub("<.*", "", type)

    switch(outer_type,
           "list" = {
             inner_type <- stringr::str_extract(type,  "(?<=<).+?(?=>$)")
             inner_types <- stringr::str_split(inner_type, " \\| ")[[1]]
             inner_values <- lapply(inner_types, function(T) generate_val(T))

             l <- list()
             mapply(function(val, i) {
               l[[i]] <<- val
             }, inner_values, seq(inner_values))

             return(l)
           },
           "class" = {
             inner_type <- stringr::str_extract(type,  "(?<=<).+?(?=>$)")
             inner_value <- lapply(inner_type, function(T) generate_val(T))

             return(inner_value)
           })

    val <- sample(255, 1)
    len <- sample(255, 1)
    RANDOM_T <- sample(c(S, V), 1)

    switch (type,
            "any" = generate_val(RANDOM_T),
            "logical" =  sample(c(TRUE, FALSE), 1),
            "integer" = val,
            "double" = as.double(val),      # three special values: Inf, -Inf, NaN
            "complex" = as.complex(val),
            "character" = as.character(val),
            "raw" = as.raw(val),
            "logical[]" =  rep(sample(c(TRUE, FALSE), 1), len),
            "integer[]" = rep(val, len),
            "double[]" = rep(as.double(val), len),      # three special values: Inf, -Inf, NaN
            "complex[]" = rep(as.complex(val), len),
            "character[]" = rep(as.character(val), len),
            "raw[]" = rep(as.raw(val), len),
            "matrix" =
              as.matrix(generate_val(RANDOM_T))
            )
  }
}


#' Computes success rate using the number of unique signatures inferred
#' @param data obtained from running feedback_loop
#' @return number of signatures successfully inferred / number of tried signatures 
#' @export
#' @examples
#' data <- feedback_loop(package = "stringr", fun_name = "str_detect", strategy = "random-feedback", budget = 343)
#' compute_suc(data)
compute_suc <- function(data) {
  sucs <- data[data$exitval == 0L, ,drop=FALSE]
  warns <- data[data$exitval == 1L, ,drop=FALSE]

  sucs_or_warns <- purrr::map_dfr(list(sucs, warns), function(x) x)

  num_suc_sigs <- length(unique(sucs_or_warns$input_type))

  percent <- num_suc_sigs/length(unique(data$input_type)) * 100

  round(percent, digits=1)
}
