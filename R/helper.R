## Function Resolution Helper Functions

# TODO: Implement
# Get a function based on the package name and function name
# @param package_name is the name of the package to look in
# @param function_name is the name of the function
# @return the specified function or NULL
get_function <- function(package_name = NULL, function_name) {}


## GBOV Interface Functions

#' @export
# Load the Great Book of Values
# @param dir the directory where the RDS files are saved
# @return GBOV
gbov_load <- function(dir) {
  path <- paste0(dir, "/", "values.RDS")
  readRDS(path)
}

#' @export
gbov_length <- function(GBOV) {
  length(GBOV)
}

# TODO: Implement
# Get the hash from the Great Book of Values at specific index
# @param GBOV is a Great Book of Values object
# @param index is a specified index of the GBOV; it must 
# @return the R value from GBOV at the specified index
gbov_get_hash <- function(GBOV, index) {}

# TODO: Implement
# Get a random hash from the Great Book of Values
# @param GBOV is a Great Book of Values object
# @return a random R value from GBOV
gbov_get_random_hash <- function(GBOV) {
  # idx <- next_random(0, gbov_len)
  # return the hash at index idx
  # gbov_get_value(GBOV, idx)
}

#' @export
# Get a random value from the Great Book of Values
# @param GBOV
# @return a random value from GBOV
gbov_get_value <- function (GBOV) {
  random <- sample.int(length(gbov), 1)
  unserialize(GBOV[[random]][[3L]])
}

#' @export
gbov_get_type <- function (value) {
  typeof(value)
}

# TODO: Implement
# Add a new value to the Great Book of Values
# @param GBOV is a Great Book of Value object that we add the value to
# @param value is the value being added
# @return hash value of generated by GBOV for the new value
gbov_add_value <- function(GBOV, value) {}


## Type Identification Helper Functions

# TODO: Implement
# Get type of the input value
# @param value is a R value that signatr_typeof can make sense of
# @return the type of the value
signatr_typeof <- function(value) {}


## Run Helper Functions

# TODO: Implement
# Run a function until a specified amount of time elapsed, or until killed
# @param f is the function to be run
# @param timeout is the amount of time to run the function
run_until_timeout_or_death <- function(timeout, f) {
  start = as.integer(Sys.time())
  while (start + timeout < as.integer(Sys.time())) {
    f
  }
}
